"use strict";(self.webpackChunkreact_hello_webapp=self.webpackChunkreact_hello_webapp||[]).push([[3508],{43508:(t,a,r)=>{r.d(a,{e:()=>b,f:()=>P});var e=r(74054),c=r(80589),n=r(4254),i=r(52367),s=r(587),o=r(31406),p=r(31007),h=r(27827),l=r(35179),m=r(61080),u=r(75640),d=r(31098);class W{featureName=i.cG.name;constructor(t,a){this.erc20=t,this.contractWrapper=a}to=(0,p.c)((async t=>{const a=new n.C(this.contractWrapper),r=(await Promise.all(t.map((t=>Promise.all([(0,i.aP)(t.toAddress),this.erc20.normalizeAmount(t.amount)]))))).map((t=>{let[r,e]=t;return a.encode("mintTo",[r,e])}));return p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r]})}))}class g{featureName=i.cH.name;constructor(t,a){this.erc20=t,this.contractWrapper=a}tokens=(0,p.c)((async t=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await this.erc20.normalizeAmount(t)]})));from=(0,p.c)((async(t,a)=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnFrom",args:await Promise.all([(0,i.aP)(t),this.erc20.normalizeAmount(a)])})))}class w{featureName=i.cI.name;constructor(t,a,r){this.erc20=t,this.contractWrapper=a,this.storage=r;const e=new o.C(this.contractWrapper,i.bk,this.storage);this.conditions=new h.D(this.contractWrapper,e,this.storage)}to=(0,p.c)((async(t,a,r)=>{const e=await this.erc20.normalizeAmount(a);return await this.conditions.getClaimTransaction(t,e,r)}))}class y{constructor(t,a,r){this.erc20=t,this.contractWrapper=a,this.storage=r,this.claim=new w(this.erc20,this.contractWrapper,this.storage)}}class f{featureName=i.cJ.name;constructor(t,a){this.erc20=t,this.contractWrapper=a,this.batch=this.detectErc20BatchMintable()}to=(0,p.c)((async(t,a)=>await this.getMintTransaction(t,a)));async getMintTransaction(t,a){return p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:await Promise.all([(0,i.aP)(t),this.erc20.normalizeAmount(a)])})}detectErc20BatchMintable(){if((0,o.d)(this.contractWrapper,"ERC20BatchMintable"))return new W(this.erc20,this.contractWrapper)}}class b{featureName=i.cK.name;constructor(t,a){this.contractWrapper=t,this.roles=a}mint=(0,p.c)((async t=>{const a=t.payload,r=t.signature,[c,n]=await Promise.all([this.mapPayloadToContractStruct(a),this.contractWrapper.getCallOverrides()]);return await(0,u.s)(this.contractWrapper,e.O$.from(c.price),a.currencyAddress,n),p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[c,r],overrides:n})}));mintBatch=(0,p.c)((async t=>{const a=await Promise.all(t.map((t=>this.mapPayloadToContractStruct(t.payload)))),r=t.map(((t,r)=>{const c=a[r],n=t.signature,i=t.payload.price;if(e.O$.from(i).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:c,signature:n}})),c=new n.C(this.contractWrapper),i=r.map((t=>c.encode("mintWithSignature",[t.message,t.signature])));return p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[i]})}));async verify(t){const a=t.payload,r=t.signature,e=await this.mapPayloadToContractStruct(a);return(await this.contractWrapper.read("verify",[e,r]))[0]}async generate(t){return(await this.generateBatch([t]))[0]}async generateBatch(t){await(this.roles?.verify(["minter"],await this.contractWrapper.getSignerAddress()));const[a,r,e]=await Promise.all([this.contractWrapper.getChainID(),this.contractWrapper.read("name",[]),Promise.all(t.map((t=>d.S.parseAsync(t))))]),c=this.contractWrapper.getSigner();(0,l.Z)(c,"No signer available");const n=await Promise.all(e.map((t=>d.k.parseAsync(t)))),i=await Promise.all(n.map((t=>this.mapPayloadToContractStruct(t)))),s=await Promise.all(i.map((t=>this.contractWrapper.signTypedData(c,{name:r,version:"1",chainId:a,verifyingContract:this.contractWrapper.address},{MintRequest:d.M},t))));return e.map(((t,a)=>({payload:n[a],signature:s[a].toString()})))}async mapPayloadToContractStruct(t){const[a,r]=await Promise.all([(0,m.n)(this.contractWrapper.getProvider(),t.price,t.currencyAddress),this.contractWrapper.read("decimals",[])]),e=c.parseUnits(t.quantity,r);return{to:t.to,primarySaleRecipient:t.primarySaleRecipient,quantity:e,price:a,currency:t.currencyAddress,validityEndTimestamp:t.mintEndTime,validityStartTimestamp:t.mintStartTime,uid:t.uid}}}class P{featureName=i.cL.name;get chainId(){return this._chainId}constructor(t,a,r){this.contractWrapper=t,this.storage=a,this.mintable=this.detectErc20Mintable(),this.burnable=this.detectErc20Burnable(),this.droppable=this.detectErc20Droppable(),this.signatureMintable=this.detectErc20SignatureMintable(),this._chainId=r}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(){return await(0,n.f)(this.contractWrapper.getProvider(),this.getAddress())}async balance(){return await this.balanceOf(await this.contractWrapper.getSignerAddress())}async balanceOf(t){return this.getValue(await this.contractWrapper.read("balanceOf",[await(0,i.aP)(t)]))}async totalSupply(){return await this.getValue(await this.contractWrapper.read("totalSupply",[]))}async allowance(t){const[a,r]=await Promise.all([this.contractWrapper.getSignerAddress(),(0,i.aP)(t)]);return await this.allowanceOf(a,r)}async allowanceOf(t,a){const r=await Promise.all([(0,i.aP)(t),(0,i.aP)(a)]);return await this.getValue(await this.contractWrapper.read("allowance",r))}transfer=(0,p.c)((async(t,a)=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transfer",args:await Promise.all([(0,i.aP)(t),this.normalizeAmount(a)])})));transferFrom=(0,p.c)((async(t,a,r)=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"transferFrom",args:await Promise.all([(0,i.aP)(t),(0,i.aP)(a),this.normalizeAmount(r)])})));setAllowance=(0,p.c)((async(t,a)=>p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approve",args:await Promise.all([(0,i.aP)(t),this.normalizeAmount(a)])})));transferBatch=(0,p.c)((async t=>{const a=new n.C(this.contractWrapper),r=(await Promise.all(t.map((t=>Promise.all([this.normalizeAmount(t.amount),(0,i.aP)(t.toAddress)]))))).map((t=>{let[r,e]=t;return a.encode("transfer",[e,r])}));return p.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r]})}));mint=(0,p.c)((async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)));mintTo=(0,p.c)((async(t,a)=>(0,s.a)(this.mintable,i.cJ).to.prepare(t,a)));async getMintTransaction(t,a){return(0,s.a)(this.mintable,i.cJ).getMintTransaction(t,a)}mintBatchTo=(0,p.c)((async t=>(0,s.a)(this.mintable?.batch,i.cG).to.prepare(t)));burn=(0,p.c)((async t=>(0,s.a)(this.burnable,i.cH).tokens.prepare(t)));burnFrom=(0,p.c)((async(t,a)=>(0,s.a)(this.burnable,i.cH).from.prepare(t,a)));claim=(0,p.c)((async(t,a)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,a)));claimTo=(0,p.c)((async(t,a,r)=>(0,s.a)(this.droppable?.claim,i.cI).to.prepare(t,a,r)));get claimConditions(){return(0,s.a)(this.droppable?.claim,i.cI).conditions}get signature(){return(0,s.a)(this.signatureMintable,i.cK)}async normalizeAmount(t){return async function(t,a){const r=await t.read("decimals",[]);return c.parseUnits(i.cz.parse(a),r)}(this.contractWrapper,t)}async getValue(t){return await(0,n.a)(this.contractWrapper.getProvider(),this.getAddress(),e.O$.from(t))}detectErc20Mintable(){if((0,o.d)(this.contractWrapper,"ERC20"))return new f(this,this.contractWrapper)}detectErc20Burnable(){if((0,o.d)(this.contractWrapper,"ERC20Burnable"))return new g(this,this.contractWrapper)}detectErc20Droppable(){if((0,o.d)(this.contractWrapper,"ERC20ClaimConditionsV1")||(0,o.d)(this.contractWrapper,"ERC20ClaimConditionsV2")||(0,o.d)(this.contractWrapper,"ERC20ClaimPhasesV1")||(0,o.d)(this.contractWrapper,"ERC20ClaimPhasesV2"))return new y(this,this.contractWrapper,this.storage)}detectErc20SignatureMintable(){if((0,o.d)(this.contractWrapper,"ERC20SignatureMintable"))return new b(this.contractWrapper)}}}}]);