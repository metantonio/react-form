"use strict";(self.webpackChunkreact_hello_webapp=self.webpackChunkreact_hello_webapp||[]).push([[5444],{72914:(t,a,e)=>{e.d(a,{D:()=>y,F:()=>p,I:()=>i,a:()=>c,b:()=>h,c:()=>l,f:()=>d,g:()=>u,u:()=>f});var r=e(75640),n=e(5716),s=e(74054),o=e(20787);const i=(()=>n.arrayify("0x80ac58cd"))(),c=(()=>n.arrayify("0xd9b67a26"))(),p={name:"Failed to load NFT metadata"};async function d(t,a,e){if(a.startsWith("data:application/json;base64")&&"undefined"!=typeof Buffer){const e=a.split(",")[1],n=JSON.parse(Buffer.from(e,"base64").toString("utf-8"));return r.C.parse({...n,id:s.O$.from(t).toString(),uri:a})}const o=a.replace("{id}",n.hexZeroPad(s.O$.from(t).toHexString(),32).slice(2));let i;try{i=await e.downloadJSON(o)}catch(r){const n=a.replace("{id}",s.O$.from(t).toString());try{i=await e.downloadJSON(n)}catch(e){console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:a})} -- falling back to default metadata`),i=p}}return r.C.parse({...i,id:s.O$.from(t).toString(),uri:a})}async function l(t,a,n,l){let h;const f=(await e.e(5025).then(e.t.bind(e,25025,19))).default,u=new o.CH(t,f,a),[y,w]=await Promise.all([u.supportsInterface(i),u.supportsInterface(c)]);if(y){const r=(await Promise.resolve().then(e.t.bind(e,34161,19))).default,s=new o.CH(t,r,a);h=await s.tokenURI(n)}else{if(!w)throw Error("Contract must implement ERC 1155 or ERC 721.");{const r=(await Promise.resolve().then(e.t.bind(e,50266,19))).default,s=new o.CH(t,r,a);h=await s.uri(n)}}return h?d(n,h,l):r.C.parse({...p,id:s.O$.from(n).toString(),uri:""})}async function h(t,a){return"string"==typeof t?t:await a.upload(r.a.parse(t))}async function f(t,a,e,n){if(function(t){return void 0===t.find((t=>"string"!=typeof t))}(t))return t;if(function(t){return void 0===t.find((t=>"object"!=typeof t))}(t)){return await a.uploadBatch(t.map((t=>r.a.parse(t))),{rewriteFileNames:{fileStartNumber:e||0},onProgress:n?.onProgress})}throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function u(t){const a=t[0].substring(0,t[0].lastIndexOf("/"));for(let e=0;e<t.length;e++){const r=t[e].substring(0,t[e].lastIndexOf("/"));if(a!==r)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${a}' but got '${r}'`)}return a.replace(/\/$/,"")+"/"}const y=100},65444:(t,a,e)=>{e.d(a,{C:()=>g,D:()=>m,a:()=>W,c:()=>I});var r=e(31406),n=e(31007),s=e(52367),o=e(4254),i=e(60941),c=e(7858),p=e(52496),d=e(5716),l=e(74054),h=e(20787),f=e(75640),u=e(72914),y=e(31098),w=e(61080);class g{featureName=s.d4.name;constructor(t,a){this.contractWrapper=t,this.metadata=a}async getDefaultRoyaltyInfo(){const[t,a]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return s.bH.parseAsync({fee_recipient:t,seller_fee_basis_points:a})}async getTokenRoyaltyInfo(t){const[a,e]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return s.bH.parseAsync({fee_recipient:a,seller_fee_basis_points:e})}setDefaultRoyaltyInfo=(0,n.c)((async t=>{const a=await this.metadata.get(),e=await this.metadata.parseInputMetadata({...a,...t}),s=await this.metadata._parseAndUploadMetadata(e);if((0,r.h)("setContractURI",this.contractWrapper)){const t=new o.C(this.contractWrapper),a=[t.encode("setDefaultRoyaltyInfo",[e.fee_recipient,e.seller_fee_basis_points]),t.encode("setContractURI",[s])];return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")}));setTokenRoyaltyInfo=(0,n.c)((async(t,a)=>{const e=s.bH.parse(a);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,e.fee_recipient,e.seller_fee_basis_points],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}))}class m{constructor(t,a,e,r){this.featureName=e,this.nextTokenIdToMintFn=r,this.contractWrapper=t,this.storage=a}createDelayedRevealBatch=(0,n.c)((async(t,a,e,r)=>{if(!e)throw new Error("Password is required");const s=await this.storage.uploadBatch([f.a.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),o=(0,u.g)(s),d=await this.nextTokenIdToMintFn(),l=await this.storage.uploadBatch(a.map((t=>f.a.parse(t))),{onProgress:r?.onProgress,rewriteFileNames:{fileStartNumber:d.toNumber()}}),h=(0,u.g)(l),y=await this.contractWrapper.read("getBaseURICount",[]),w=await this.hashDelayRevealPassword(y,e),g=await this.contractWrapper.read("encryptDecrypt",[i.Y0(h),w]);let m;if(await this.isLegacyContract())m=g;else{const t=await this.contractWrapper.getChainID(),a=c.keccak256(["bytes","bytes","uint256"],[i.Y0(h),w,t]);m=p.$.encode(["bytes","bytes32"],[g,a])}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[l.length,o.endsWith("/")?o:`${o}/`,m],parse:t=>{const a=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),e=a[0].args.startTokenId,r=a[0].args.endTokenId,n=[];for(let a=e;a.lte(r);a=a.add(1))n.push({id:a,receipt:t});return n}})}));reveal=(0,n.c)((async(t,a)=>{if(!a)throw new Error("Password is required");const e=await this.hashDelayRevealPassword(t,a);try{const a=await this.contractWrapper.callStatic().reveal(t,e);if(!a.includes("://")||!a.endsWith("/"))throw new Error("invalid password")}catch(t){throw new Error("invalid password")}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,e]})}));async getBatchesToReveal(){const t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];const a=Array.from(Array(t.toNumber()).keys()),e=await Promise.all(a.map((t=>{if((0,r.h)("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[t]);if((0,r.h)("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[t]);throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")}))),n=e.slice(0,e.length-1),s=await Promise.all(Array.from([0,...n]).map((t=>this.getNftMetadata(t.toString())))),o=await this.isLegacyContract(),i=(await Promise.all(Array.from([...e]).map((t=>o?this.getLegacyEncryptedData(t):this.contractWrapper.read("encryptedData",[t]))))).map((t=>{if(d.hexDataLength(t)>0){if(o)return t;return p.$.decode(["bytes","bytes32"],t)[0]}return t}));return s.map(((t,a)=>({batchId:l.O$.from(a),batchUri:t.uri,placeholderMetadata:t}))).filter(((t,a)=>d.hexDataLength(i[a])>0))}async hashDelayRevealPassword(t,a){const e=await this.contractWrapper.getChainID(),r=this.contractWrapper.address;return c.keccak256(["string","uint256","uint256","address"],[a,e,t,r])}async getNftMetadata(t){return(0,u.c)(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if((0,r.h)("contractVersion",this.contractWrapper))try{return await this.contractWrapper.read("contractVersion",[])<=2}catch(t){return!1}return!1}async getLegacyEncryptedData(t){const a=(await e.e(8839).then(e.t.bind(e,98839,19))).default,r=new h.CH(this.contractWrapper.address,a,this.contractWrapper.getProvider()),n=await r.functions.encryptedBaseURI(t);return n.length>0?n[0]:"0x"}}async function I(t,a,e,r,n){let o={};const i=r||s.aZ,c=(await(0,w.n)(t.getProvider(),a,i)).mul(e);return c.gt(0)&&(i===s.aZ?o={value:c}:i!==s.aZ&&n&&await(0,y.a)(t,i,c,e,0)),o}class W{featureName=s.d5.name;constructor(t){this.contractWrapper=t}async get(){return this.contractWrapper.read("owner",[])}set=(0,n.c)((async t=>{const a=await(0,s.aP)(t);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[a]})}))}}}]);